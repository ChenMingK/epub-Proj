本项目将根据我写的<a href="https://blog.csdn.net/qq_37205708/article/details/89737524">这篇文章</a>进行优化
### 划分子域、DNS预解析
由于只有一个域名所以放弃
### CND加速
可以考虑把vuex、vue-router等插件不直接放到打包后的文件中而是通过外链来引入，比如

``` javaScript
const cdn = {
 // 开发环境
 dev: {
 css: [
  'https://unpkg.com/element-ui/lib/theme-chalk/index.css',
  'https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css'
 ],
 js: []
 },
 // 生产环境
 build: {
 css: [
  'https://unpkg.com/element-ui/lib/theme-chalk/index.css',
  'https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css'
 ],
 js: [
  'https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js',
  'https://cdn.jsdelivr.net/npm/vue-router@3.0.1/dist/vue-router.min.js',
  'https://cdn.jsdelivr.net/npm/vuex@3.0.1/dist/vuex.min.js',
  'https://cdn.jsdelivr.net/npm/axios@0.18.0/dist/axios.min.js',
  'https://unpkg.com/element-ui/lib/index.js',
  'https://cdn.bootcss.com/js-cookie/2.2.0/js.cookie.min.js',
  'https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js'
 ]
 }
}
```
另外，还可以把一些不变的图片什么的放在七牛云的图床上通过外链来加载。简单来说，就是找同样的资源你的服务器慢别人的服务器快；
因为浏览器可以并行地建立多个TCP连接（5个还是6个来着？），所以应该不用怀疑额外的DNS解析和TCP握手所耗费的时间会比原来的多。
### 设置缓存---采纳
考虑对图片和html资源等设置缓存，正在研究如何设置......
### 图片懒加载---采纳
书城页有大量图片目前是一次性加载的，又因为购买的阿里云服务器的网速贼慢，所以考虑图片懒加载，考虑使用vue-lazyloader<br>
具体的使用可以参考<a href="https://segmentfault.com/a/1190000014928116">这篇文章</a>或者去看官方文档<br>
- `cnpm install vue-lazyload --save` 因为是生产环境需要使用的不要用--save-dev<br>
- main.js导入 `import import VueLazyLoad from 'vue-lazyload'` `Vue.use(VueLazyLoad)`
- `<img class="item-pic" v-lazy="newItem.picUrl"/>` vue文件中将需要懒加载的图片绑定 v-bind:src 修改为 v-lazy 

当然也不是要把所有的图片都换成懒加载，这是吃力不讨好的，这里我只把书城部分需要滑动才能看到的图片使用了懒加载其他地方不换
因为一点进去就能看到的话懒加载也没有意义，图片个数本来不多的话懒加载也没有意义，只有在一个页面加载了过多视图还看不到的图片这种场景再用懒加载。
这个插件还提供了许多API可以满足不同需求，这里不再探讨了
### 预加载-采纳
在阅读器部分可以考虑预先加载当前章节相邻的章节内容，这样切换时可以有更好的体验。电子书阅读器实现原理都是类似的，可以将epub电子书解压观察一下，每一章其实是一个html文件，阅读器每次加载一章就是这个道理，当翻阅到下一章时，阅读器需要再解析下一个html文件，可以考虑预先加载前后两章，这样在边界处翻页时，也能获得很好的阅读体验。
### 链接位置
这个Webpack帮我们处理了
### 尽量减少回流与重绘---采纳
CSS3动画全部使用`transform:translate3D()`启动GPU加速
### 高效率的CSS，不要有过多的嵌套
懒得改CSS了......
### 减少DOM元素数量、DOM操作---采纳
考虑把使用JS操作DOM实现的动画换成canvas实现
### 函数节流---采纳
项目中监听了很多的vuex变量，考虑从连续的监听换成有间断的监听
### iconfont图标---已使用

### 文件体积优化
可以通过安装webpack的一些插件以及配置vue.config.js来减小打包后的文件的体积，这里先给出未做打包优化前的文件大小<br>
未打包优化前，文件大小：**4.79MB**<br>

优化1：配置productionSourceMap选项，只需要在vue.config.js中增加` productionSourceMap: false`<br>
官网解释如下：如果你不需要生产环境的 source map，可以将其设置为 false 以加速生产环境构建；<br>
网上找到的解释是：map文件是js文件压缩后，文件的变量名替换对应、变量所在位置等原信息数据文件。
个人理解是对js压缩过程的记录，如浏览器支持等，可以通过map文件还原文件到未压缩之前。<br>
重新打包后文件大小为**1.54MB**，可以发现体积大大减小

优化2：使用图片压缩插件<br>
`npm install image-webpack-loader --save-dev`

``` javaScript
chainWebpack: config => {
  config.module
      .rule('images')
      .use('image-webpack-loader')
      .loader('image-webpack-loader')
      .options({
        bypassOnDebug: true
      })
      .end()
},
```
这段代码做了两件事：一是压缩，二是转Base64可以发现在dist/img下面的图片少了一部分，
原因是：不超过4096字节会被转换成Base64编码,用require引用的也会被转成和base64，超出这个限制则会被打包在img文件夹下。
重新打包后文件大小为**1.40MB**，少了将近0.1MB


### SPA SEO or SSR?
- SPA(Single Page Application)：单页面富应用，动态地重写页面的部分与用户交互而不是重新加载新的页面
- SEO(Search Engine Optimization)：搜索引擎优化
- SSR(Server-Side Rendering)：服务端渲染

本项目属于SPA，不需要SEO，SSR理论上来说不仅会有更快的首屏加载时间，同时也能获得更好的SEO但是其会占用服务器更多的CPU和内存资源，且
一些常用的浏览器API可能无法使用，如window、document、alert等；对于一个已经上线的项目来说修改成本也挺大的（感觉），且本项目不想
电商网站之类的对首屏加载速度有太高的要求，因为首屏是书架页面，只显示自己选定的图书，所以不考虑SSR。

### 用户体验优化
1. 添加书签的操作增加PC端适配
2. 增加对屏幕宽度的监听以实现响应式布局
3. localStorage和IndexedDB的使用似乎仍然有一些问题
