## 需求分析
<span><img src="https://github.com/ChenMingK/ImagesStore/blob/master/imgs/epubProj1.png" width=400px></span>&emsp;&emsp;&emsp;
<span><img src="https://github.com/ChenMingK/ImagesStore/blob/master/imgs/epubProj2.png" width=200px></span><br><br>
- 点击阅读器主体中间部分显示菜单栏，再次点击后隐藏；点击主体左侧部分跳转到上一页，点击右侧部分跳转到下一页；<br>
- 菜单栏选项：目录/书签，进度查看及跳转，主题切换，字号/字体设置

## 代码结构
|-- public<br>
&emsp;     |-- favicon.ico &emsp;       	// favicon图标<br>
&emsp;     |-- index.html &emsp;        // 项目入口文件(打包前的index)<br>
|-- src<br>
|&emsp;    |-- api &emsp;              	 // 所有API请求(axios)<br>
|&emsp;    |-- assets &emsp;            	 // 主题、字体等静态资源、样式<br>
|&emsp;    |-- components &emsp;      	 // 各种组件<br>
&emsp;&emsp;  	  |-- EbookBookmark.vue &emsp; 	// 蒙版组件<br>
&emsp;&emsp;  	  |-- EbookFooter.vue	&emsp; 	// 页脚组件<br>
&emsp;&emsp;  	  |-- EbookHeader.vue &emsp; 	// 页眉组件<br>
&emsp; &emsp; 	  |-- EbookLoading.vue	&emsp;  // 加载动画组件<br>
&emsp;&emsp;  	  |-- EbookMenu.vue	&emsp; 	// （下方）菜单栏组件<br>
&emsp;&emsp;  	  |-- EbookTitle.vue	&emsp; 	// 上方标题组件（与菜单栏一同时）<br>
&emsp;&emsp;  	  |-- EbookReader.vue	&emsp; 	// 挂载电子书的组件<br>
&emsp;&emsp; 	  |-- EbookSettingFont.vue &emsp; 	// 设置字体的组件<br>
&emsp;&emsp; 	  |-- EbookSettingFontPopup.vue &emsp;  // 选择字体时的弹窗组件<br>
&emsp;&emsp; 	  |-- EbookSettingProgress.vue	&emsp;   // 显示阅读进度组件<br>
&emsp;&emsp; 	  |-- EbookSettingTheme.vue	 &emsp;  // 设置主题组件<br>
&emsp;&emsp; 	  |-- EbookSlide.vue	&emsp; 		  // 目录组件<br>
&emsp;&emsp; 	  |-- EbookSlideBookmark.vue	&emsp;   // 滚动蒙版组件<br>
&emsp;&emsp; 	  |-- EbookSlideContents.vue	&emsp;   // 滚动内容组件<br>
|&emsp;    |-- lang    &emsp;          	 //; vue-i18n配置(语言国际化)<br>
&emsp;&emsp; 	  |-- cn.js		&emsp; 	 // 中文内容<br>
&emsp;&emsp; 	  |-- en.js	&emsp; 	 // 英文内容<br>
&emsp;&emsp; 	  |-- index.js		&emsp; 	 // 导出vuei18n（main.js引入）<br>
|&emsp;    |-- store   &emsp;         	 // vuex<br>
&emsp;&emsp; 	  |-- modules<br>&emsp; 
&emsp;&emsp;&emsp; 	  	 |-- book.js	&emsp; 	 // 定义阅读器部分vuex的state和mutations<br>
&emsp;&emsp; 	  |-- action.js	&emsp; 		 // 定义actions（for mapActions）<br>
&emsp;&emsp; 	  |-- getter.js	&emsp; 		 // 定义getters（for mapGetters）<br>
&emsp;&emsp; 	  |-- index.js	&emsp; 		 // 导出vuex（main.js引入）<br>
|&emsp;    |-- utils    &emsp;         	 // 全局公用方法<br>
|&emsp;    |-- views   &emsp;          	 // 视图组件(用于展示页面的组件)<br>
&emsp;&emsp; 	   |-- ebook<br>
&emsp;&emsp;&emsp; 		  |-- index.vue	&emsp;  // 阅读器入口<br>
|&emsp;   |-- App.vue    &emsp;       	 // 入口页面<br>
|&emsp;   |-- main.js    &emsp;       	 // 入口 加载组件 初始化等<br>
|&emsp;  |-- router.js  &emsp;        	// vue-router定义路由<br>
以下省略<br>

## 组件关系
<img src="https://github.com/ChenMingK/ImagesStore/blob/master/imgs/epubProj3.png">
简单说明： 整个阅读器部分就是一个视图组件Index.vue, 该组件又被划分为Header(头部文字信息), Title(顶部菜单栏), Reader(阅读器主体), Menu(底部菜单栏), BookMark(书签组件), 
Footer(底部文字信息); <br>Menu组件又包括了目录、进度、主题、字体设置4个组件; <br>EbookSlide即点击目录tab时弹出的侧边栏, 其有一个加载动画组件(EbookLoading.vue),
以及目录和书签组件, 其共用一个Scroll公共组件.

## 主要技术难点
### 1.vuex+mixin实现组件解耦, 减少重复代码
通过vuex和mixin机制实现组件解耦，好处是便于维护，每个组件只需要关注自身内部的内容，当组件之间发生交互时，只需要改变vuex的值即可。组件较多且组件结构较为复杂时使用。
<br>组件解耦：即有交互关系的两个组件不需要知道彼此的存在

``` javaScript
在utils文件夹下创建mixin.js
import { mapGetters, mapActions } from 'vuex'
export const ebookMixin = { 
  computed: {
	// 简化vuex的书写, 通过this.xxx获取vuex的state
    ...mapGetters([
      'fileName',
      'menuVisible',
	  ……
    ]),
    themeList() {
      return themeList(this)
    }
  },
  // 简化vuex的书写, 通过this.xxx调用vuex的commit（提交一个注册的事件，返回Promise）代替this.$store.dispatch(‘事件名’, 参数)
  methods: {
    ...mapActions([
      'setFileName',
      'setMenuVisible',
      ……
]),
// 可以继续添加其他自定义方法
   },
mapGetters混入computed中，mapActions混入methods中
在组件中通过两步导入mixin
import { ebookMixin } from '../../utils/mixin'
export default {
	mixins: [ebookMixin]
}
```
### 2.vue-i18n实现字体国际化
src下创建lang文件夹<br>
`cnpm i –save vue-i18n`安装插件<br>
(1).在lang文件夹下创建资源文件cn.js en.js或者更多种语言<br>
(2).在lang文件夹下创建index.js如下<br>
``` javaScript
import Vue from 'vue'
import VueI18N from 'vue-i18n' // 引入插件
import en from './en' // 引入资源文件
import cn from './cn'
import { getLocale, saveLocale } from '../utils/localStorage' // 引入缓存设置

Vue.use(VueI18N) // 加载插件
const messages = {
  en,
  cn
}

let locale = getLocale() // 读取缓存中设置的字体
if (!locale) {
  locale = 'cn'
  saveLocale(locale)
}
// 实例化VueI18N
const i18n = new VueI18N({
  locale, // 当前语言
  messages // 语言对应的文本
})

export default i18n
```
(3).main.js导入<br>

``` javaScript
mport i18n from ‘./lang’
new Vue({
  i18n
  ……
}).$mount(‘#app’)
```
(4).使用方式$t('xx')<br>
html中`{{$t('book.selectFont')}}`, js中`$t('book.pulldownAddMark')`

### 3.动态切换主题
内层阅读器样式需要通过themes对象实现，外层界面样式(即除去阅读器部分的其他样式, 比如菜单栏颜色等)切换需要通过动态加载css来实现。<br>
阅读器的主题注册见阅读器相关API部分, 这里主要介绍通过动态添加css样式实现主题切换的方法<br>
动态添加css，样式资源存放在Nginx静态资源服务器里，统一加上!import以覆盖其他样式

``` javaScript
// 全局主题设置功能实现(包括菜单栏等)
export function addCss(href) {
  const link = document.createElement('link') // 创建link标签
  link.setAttribute('rel', 'stylesheet')      // 设置属性：样式表
  link.setAttribute('type', 'text/css')       // css文件
  link.setAttribute('href', href)             // 路径
  document.getElementsByTagName('head')[0].appendChild(link) // 相当于通过link标签引入新的css样式
}
```
所谓动态添加css, 以DOM的层面来讲, 即创建一个link节点, 设置其rel和type属性, href指向静态资源服务器提供的存放css样式文件的地址, 
然后将这个link节点添加到head节点下(这里是通过appendChild(link)添加到末尾).<br>
<img src="https://github.com/ChenMingK/ImagesStore/blob/master/imgs/epubProj17.png"><br>
但是要注意如果用户一直点切换主题, 而之前添加的link节点又没有被删除的话, 虽然通过!importang能实现后面的样式覆盖之前的, 但是会降低渲染效率, 所以
为了防止重复添加样式文件, 每次执行添加操作之前需要删除之前的样式文件.具体如下:<br>

``` javaScript
// 上面用的是添加样式，重复添加只是覆盖之前的效果，加载了多个CSS，需要删除之前的
export function removeCss(href) {
  const links = document.getElementsByTagName('link')
  for (let i = links.length; i >= 0; i--) { // 从后往前遍历
    const link = links[i]
    if (link && link.getAttribute('href') && link.getAttribute('href') === href) {
      link.parentNode.removeChild(link) // 调用head标签的removeChild, 要删除的那个节点, 而不是传入节点下标什么的
    }
  }
}
// 这里设置一个删除全部的css样式的方法, 通过匹配href属性来删除, 注意不能删除其他的样式
export function removeAllCss() {
  removeCss(`${process.env.VUE_APP_RES_URL}/theme/theme_default.css`)
  removeCss(`${process.env.VUE_APP_RES_URL}/theme/theme_eye.css`)
  removeCss(`${process.env.VUE_APP_RES_URL}/theme/theme_gold.css`)
  removeCss(`${process.env.VUE_APP_RES_URL}/theme/theme_night.css`)
}
```
removeAllCss()方法即快速删除所有之前添加的样式, 因为静态资源服务器存放样式文件的位置是固定的: ip + 端口 + 文件路径, 再把将LINK节点从DOM中删除
的过程封装为一个removeCss(href)方法, 遍历所有link节点删除href属性与参数相同的. 注意删除节点的操作要通过parentNode获取父节点再调用removeChild()
方法.<br>

更多关于DOM的操作我整理在这篇文章中，CTRL点击<a href="https://blog.csdn.net/qq_37205708/article/details/89414941">传送门</a>
### 4.书签手势操作
<img src="https://github.com/ChenMingK/ImagesStore/blob/master/imgs/bookmarkgif.gif" width=300px><br>
**需求分析：**<br>
1.将标题和菜单栏隐藏后才能进行手势操作<br>
2.未添加书签的页面下拉后添加书签<br>
3.添加过书签的页面下拉后删除书签<br>
4.可以通过书签直接跳转到对应的页面

**实现思路：**<br>
书签的添加由EbookReader和EbookBookmark两个组件配合完成，EbookReader组件通过touchmove和touchend事件监听手指的滑动，计算出一个Y轴偏移量offsetY
并传入vuex，EbookBookmark组件将offsetY设置为监听属性进而响应变化。注意这里在EbookBookmark中又将书签抽离为一个Bookmark组件，因为添加书签之后书签会固定在右上角但是文字和箭头却是不会显示的。

**具体过程:**<br>
这里将书签的添加过程分为以下几个阶段：<br>
第一阶段：自然下拉阶段，书签组件跟随屏幕移动而移动<br>
第二阶段：吸顶阶段，拖动值到达书签组件高度35px时书签不随屏幕移动，吸顶效果可以通过相对位移实现<br>
第三阶段：可添加状态，拖动高度超过临界值，箭头向上，文字改变，书签变色，松手后书签添加成功，覆盖在右上方<br>
书签组件高度设定为35px，临界值设定为55px，将监听到的offsetY与这两个值比较进而判定现在属于哪个阶段而做出响应。

**思考1**:如何计算出下拉距离？<br>
首先要知道三个移动端事件：<br>
1)touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。<br>
2)touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。<br>
3)touchend事件：当手指从屏幕上离开的时候触发。<br>
这里做了个简单的demo <a href="https://github.com/ChenMingK/demos/blob/master/bookmark.html">demo传送门</a><br>
简单来说，手指按下屏幕时记录一个初始的Y轴偏移量firstOffsetY，然后移动下拉时会一直触发touchmove事件，通过e.changedTouches[0].clientY获取
此时的Y轴偏移量与firstOffsetY相减就是下拉的距离了。<br>
截取部分代码如下:<br>

``` javaScript
// 确定屏幕Y轴偏移量
move(e) {
  let offsetY = 0
  if (this.firstOffsetY) {
  offsetY = e.changedTouches[0].clientY - this.firstOffsetY // this - vue
  this.setOffsetY(offsetY) // offsetY存入vuex以便书签监听
} else {
  this.firstOffsetY = e.changedTouches[0].clientY // firstOffsetY记录本次手势操作开始时Y轴偏移
}
  e.preventDefault()  // 防止下拉时显示些多余的东西
  e.stopPropagation() // 禁止传播
},
// 手指离开屏幕需要还原firstOffsetY
moveEnd(e) {
  this.setOffsetY(0)
  this.firstOffsetY = 0
},
```
需要说明的是，有些时候移动端的下拉操作往往会触发其他事件，比如显示些文字什么的，微信里显示小程序什么的。所以要用preventDefault()，
stopPropagation()禁止默认事件以及防止向上冒泡。

**思考2**:如何实现下拉时的"屏幕移动"效果？<br>
index.vue采用绝对定位监听offsetY来改变top值就可以实现下拉的效果<br>
同时在app.vue中将背景色设置为灰色，这样下拉时就会拉出灰色。

``` javaScript
watch: {
      offsetY(v) { // 如果在methods中，vuex中的offsetY需要由
        // 标题和菜单出现时不允许添加书签，因为会造成覆盖
        if (!this.menuVisible && this.bookAvailable) {
          if (v > 0) {
            this.move(v)
          } else if (v === 0) {
            this.restore() // restore screen
          }
        }
      }
    },
methods: {
restore(v) {
  this.$refs.ebook.style.top = 0
  this.$refs.ebook.style.transition = `all .2s linear `
  // 需要清除这个动画，否则下次下拉也会触发造成不流畅
  setTimeout(() => {
    this.$refs.ebook.style.transition = ''
  }, 200)
},
move(v) {
  this.$refs.ebook.style.top = v + 'px'
},
```
通过改变样式中的top值就可以实现逐渐下拉的效果，这里要注意下拉之后的复原，以及过渡动画的设置与清除。<br>

**思考3**:书签怎么画？<br>
通过border属性画一个书签，width和height都设为0的话border就相当于4个三角形在拼接，这里隐藏下方的三角形，同时延伸上方的三角形。

``` css
.bookmark {
    width: 0;
    height: 0;
    border-width: px2rem(50) px2rem(10) px2rem(10) px2rem(10);
    border-style: solid;
    border-color: white white transparent white; // top right down left 
 }
```

**思考4**:添加书签后怎么固定在右上角？<br>
给书签部分动态绑定一个样式，超过临界值后position设置为fixed，如下<br>

``` html
<div class="ebook-bookmark-icon-wrapper" :style="isFixed ? fixedStyle : {}">
  <bookmark :color="color" :width="15" :height="35"></bookmark>
</div>
```

``` javaScript
fixedStyle() {
  return {
    position: 'fixed',
    top: 0,
    right: `${(window.innerWidth - this.$refs.bookmark.clientWidth) / 2}px`
  }
}
```
更多细节见EbookBookmark.vue组件
### 5.阅读进度功能实现
<img src="https://github.com/ChenMingK/ImagesStore/blob/master/imgs/ebookProgress.gif.gif" width=300px><br>
这里主要配合使用了H5的Input Range和background-size属性实现进度条拖动时的颜色效果，**拖动滑块**时会触发input事件，
**拖动完滑块**时会触发change事件，另外Input Range可以设置如下属性<br><br>
<img src="https://github.com/ChenMingK/ImagesStore/blob/master/imgs/epubProj11.png" width=450px><br>

``` html
<input class="progress" type="range"
	max="100"
	min="0"
	step="1"
	@change="onProgressChange($event.target.value)" @input="onProgressInput($event.target.value)"
	:value="progress"
	:disabled="!bookAvailable"
	ref="progress">
```
通过Locations对象的cfiFromPercentage方法，传入一个百分比，获得一个cfi对象，rendition.display()传入这个cfi对象即可实现阅读器的进度跳转<br>

``` javaScript
// 显示当前进度（拖动完进度触发）
onProgressChange() {
  // cfi:locations对象方法->通过百分比来获取cfi，传递个小数
  const cfi = this.currentBook.locations.cfiFromPercentage(this.progress / 100)
  this.display(cfi)
},
onProgressInput(progress) {
  this.setProgress(progress)
},
// 拖动进度条时颜色发生变化
updateProgressBg() {
  // ref用于给元素或子组件注册引用信息，引用信息将会注册在父组件的$refs对象上
  this.$refs.progress.style.backgroundSize = `${this.progress}% 100%`
},

// 使用vue的钩子函数updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。  
updated() {
  this.updateProgressBg() // 更新css中的background-size属性值以实现一种进度条移动效果
}
```
这里我也写了个demo<a href="https://github.com/ChenMingK/demos/blob/master/ebookProgress.html">传送门</a>
### 6.多级目录展示
### 7.加载动画的实现
### 8.vue-transition过渡动画的使用
### 9.公共组件Scroll.vue的开发
需求分析：<br>
1.Y轴方向滚动，隐藏滚动条<br>
2.可以动态设置整个组件的高度<br>
3.外部可以设置滚动位置，比如回到顶部<br>
4.可以往其中插入其他组件等<br>

```
<!--通用的滚动条组件-->
<template>
  <div class="scroll-wrapper" 
       :class="{'no-scroll': ifNoScroll}"
       @scroll.passive="handleScroll"
       ref="scrollWrapper"> <!--@scroll监听鼠标滚轮事件 .passive 滚动事件的默认行为会立即触发, 而不会等待'onScroll'完成-->
      <slot></slot><!--利用插槽往滚动条中填充内容-->
  </div>
</template>

<script>
  import { realPx } from '@/utils/utils'
  export default {
    props: {
      // 需要由父组件传入距离上方和下方的距离以确定滚动组件高度
      top: {
        type: Number,
        default: 0
      },
      bottom: {
        type: Number,
        default: 0
      },
      ifNoScroll: {
        type: Boolean,
        default: false
      }
    },
    methods: {
      // 鼠标滚动时监听高度偏移量并传递给父组件, scrollTop ? pageYOffset?
      handleScroll(e) {
        const offsetY = e.target.scrollTop || window.pageYOffset || document.body.scrollTop
        this.$emit('onScroll', offsetY)
      },
      // 初始化组件高度, 利用传入的top 和 bottom, 且给div添加scroll事件监听器
      refresh() {
        if (this.$refs.scrollWrapper) {
          this.$refs.scrollWrapper.style.height = window.innerHeight - 
            realPx(this.top) - realPx(this.bottom) + 'px'
          this.$refs.scrollWrapper.addEventListener('scroll', this.handleScroll)
        }
      },
      // 提供给外部的方法, 比如需要重置滚动的位置则传入0, 0参数
      scrollTo(x, y) {
        this.$refs.scrollWrapper.scrollTo(x, y)
      }
    },
    mounted() {
      this.refresh()
    }
  }
</script>

<style lang='scss' scoped>
  @import "../../assets/styles/global.scss";
  .scroll-wrapper {
    position: relative;
    z-index: 100;
    width: 100%;
    height: 100%;
    overflow-x: hidden;
    overflow-y: scroll;
    -webkit-overflow-scrolling: touch; // 解决移动端卡顿
    // 隐藏滚动条
    &::-webkit-scrollbar {
      display: none;
    }
    &.no-scroll {
      overflow: hidden;
    }
  }
</style>
```
主要实现思路：<br>
- 接收父组件传入的top和bottom值可以根据不同的需求设置Scroll组件的整体高度
- 整个Scroll组件有一个最外层div，为其增加一个事件监听器监听滚动事件，滚动时向父组件发送一个滚动的事件同时将offSetY作为参数传入($emit)
- 通过原生JS的scrollTo方法提供给外部一个操作滚动位置的方法
- 通过插槽(slot)实现父组件根据需求往Scroll组件中添加其他内容
