## 需求分析
<span><img src="https://github.com/ChenMingK/ImagesStore/blob/master/imgs/epubProj1.png" width=400px></span>&emsp;&emsp;&emsp;
<span><img src="https://github.com/ChenMingK/ImagesStore/blob/master/imgs/epubProj2.png" width=200px></span><br><br>
- 点击阅读器主体中间部分显示菜单栏，再次点击后隐藏；点击主体左侧部分跳转到上一页，点击右侧部分跳转到下一页；<br>
- 菜单栏选项：目录/书签，进度查看及跳转，主题切换，字号/字体设置

## 代码结构
|-- public<br>
&emsp;     |-- favicon.ico &emsp;       	// favicon图标<br>
&emsp;     |-- index.html &emsp;        // 项目入口文件(打包前的index)<br>
|-- src<br>
|&emsp;    |-- api &emsp;              	 // 所有API请求(axios)<br>
|&emsp;    |-- assets &emsp;            	 // 主题、字体等静态资源、样式<br>
|&emsp;    |-- components &emsp;      	 // 各种组件<br>
&emsp;&emsp;  	  |-- EbookBookmark.vue &emsp; 	// 蒙版组件<br>
&emsp;&emsp;  	  |-- EbookFooter.vue	&emsp; 	// 页脚组件<br>
&emsp;&emsp;  	  |-- EbookHeader.vue &emsp; 	// 页眉组件<br>
&emsp; &emsp; 	  |-- EbookLoading.vue	&emsp;  // 加载动画组件<br>
&emsp;&emsp;  	  |-- EbookMenu.vue	&emsp; 	// （下方）菜单栏组件<br>
&emsp;&emsp;  	  |-- EbookTitle.vue	&emsp; 	// 上方标题组件（与菜单栏一同时）<br>
&emsp;&emsp;  	  |-- EbookReader.vue	&emsp; 	// 挂载电子书的组件<br>
&emsp;&emsp; 	  |-- EbookSettingFont.vue &emsp; 	// 设置字体的组件<br>
&emsp;&emsp; 	  |-- EbookSettingFontPopup.vue &emsp;  // 选择字体时的弹窗组件<br>
&emsp;&emsp; 	  |-- EbookSettingProgress.vue	&emsp;   // 显示阅读进度组件<br>
&emsp;&emsp; 	  |-- EbookSettingTheme.vue	 &emsp;  // 设置主题组件<br>
&emsp;&emsp; 	  |-- EbookSlide.vue	&emsp; 		  // 目录组件<br>
&emsp;&emsp; 	  |-- EbookSlideBookmark.vue	&emsp;   // 滚动蒙版组件<br>
&emsp;&emsp; 	  |-- EbookSlideContents.vue	&emsp;   // 滚动内容组件<br>
|&emsp;    |-- lang    &emsp;          	 //; vue-i18n配置(语言国际化)<br>
&emsp;&emsp; 	  |-- cn.js		&emsp; 	 // 中文内容<br>
&emsp;&emsp; 	  |-- en.js	&emsp; 	 // 英文内容<br>
&emsp;&emsp; 	  |-- index.js		&emsp; 	 // 导出vuei18n（main.js引入）<br>
|&emsp;    |-- store   &emsp;         	 // vuex<br>
&emsp;&emsp; 	  |-- modules<br>&emsp; 
&emsp;&emsp;&emsp; 	  	 |-- book.js	&emsp; 	 // 定义阅读器部分vuex的state和mutations<br>
&emsp;&emsp; 	  |-- action.js	&emsp; 		 // 定义actions（for mapActions）<br>
&emsp;&emsp; 	  |-- getter.js	&emsp; 		 // 定义getters（for mapGetters）<br>
&emsp;&emsp; 	  |-- index.js	&emsp; 		 // 导出vuex（main.js引入）<br>
|&emsp;    |-- utils    &emsp;         	 // 全局公用方法<br>
|&emsp;    |-- views   &emsp;          	 // 视图组件(用于展示页面的组件)<br>
&emsp;&emsp; 	   |-- ebook<br>
&emsp;&emsp;&emsp; 		  |-- index.vue	&emsp;  // 阅读器入口<br>
|&emsp;   |-- App.vue    &emsp;       	 // 入口页面<br>
|&emsp;   |-- main.js    &emsp;       	 // 入口 加载组件 初始化等<br>
|&emsp;  |-- router.js  &emsp;        	// vue-router定义路由<br>
以下省略<br>

## 组件关系
<img src="https://github.com/ChenMingK/ImagesStore/blob/master/imgs/epubProj3.png">
简单说明： 整个阅读器部分就是一个视图组件Index.vue, 该组件又被划分为Header(头部文字信息), Title(顶部菜单栏), Reader(阅读器主体), Menu(底部菜单栏), BookMark(书签组件), 
Footer(底部文字信息); <br>Menu组件又包括了目录、进度、主题、字体设置4个组件; <br>EbookSlide即点击目录tab时弹出的侧边栏, 其有一个加载动画组件(EbookLoading.vue),
以及目录和书签组件, 其共用一个Scroll公共组件.

## 主要技术难点
### 1.vuex+mixin实现组件解耦, 减少重复代码
通过vuex和mixin机制实现组件解耦，好处是便于维护，每个组件只需要关注自身内部的内容，当组件之间发生交互时，只需要改变vuex的值即可。组件较多且组件结构较为复杂时使用。
<br>组件解耦：即有交互关系的两个组件不需要知道彼此的存在

``` javaScript
在utils文件夹下创建mixin.js
import { mapGetters, mapActions } from 'vuex'
export const ebookMixin = { 
  computed: {
	// 简化vuex的书写, 通过this.xxx获取vuex的state
    ...mapGetters([
      'fileName',
      'menuVisible',
	  ……
    ]),
    themeList() {
      return themeList(this)
    }
  },
  // 简化vuex的书写, 通过this.xxx调用vuex的commit（提交一个注册的事件，返回Promise）代替this.$store.dispatch(‘事件名’, 参数)
  methods: {
    ...mapActions([
      'setFileName',
      'setMenuVisible',
      ……
]),
// 可以继续添加其他自定义方法
   },
mapGetters混入computed中，mapActions混入methods中
在组件中通过两步导入mixin
import { ebookMixin } from '../../utils/mixin'
export default {
	mixins: [ebookMixin]
}
```
### 2.vue-i18n实现字体国际化
src下创建lang文件夹<br>
`cnpm i –save vue-i18n`安装插件<br>
(1).在lang文件夹下创建资源文件cn.js en.js或者更多种语言<br>
(2).在lang文件夹下创建index.js如下<br>
``` javaScript
import Vue from 'vue'
import VueI18N from 'vue-i18n' // 引入插件
import en from './en' // 引入资源文件
import cn from './cn'
import { getLocale, saveLocale } from '../utils/localStorage' // 引入缓存设置

Vue.use(VueI18N) // 加载插件
const messages = {
  en,
  cn
}

let locale = getLocale() // 读取缓存中设置的字体
if (!locale) {
  locale = 'cn'
  saveLocale(locale)
}
// 实例化VueI18N
const i18n = new VueI18N({
  locale, // 当前语言
  messages // 语言对应的文本
})

export default i18n
```
(3).main.js导入<br>

``` javaScript
mport i18n from ‘./lang’
new Vue({
  i18n
  ……
}).$mount(‘#app’)
```
(4).使用方式$t('xx')<br>
html中`{{$t('book.selectFont')}}`, js中`$t('book.pulldownAddMark')`

### 3.动态切换主题
内层阅读器样式需要通过themes对象实现，外层界面样式(即除去阅读器部分的其他样式, 比如菜单栏颜色等)切换需要通过动态加载css来实现。<br>
阅读器的主题注册见阅读器相关API部分, 这里主要介绍通过动态添加css样式实现主题切换的方法<br>
动态添加css，样式资源存放在Nginx静态资源服务器里，统一加上!import以覆盖其他样式

``` javaScript
// 全局主题设置功能实现(包括菜单栏等)
export function addCss(href) {
  const link = document.createElement('link') // 创建link标签
  link.setAttribute('rel', 'stylesheet')      // 设置属性：样式表
  link.setAttribute('type', 'text/css')       // css文件
  link.setAttribute('href', href)             // 路径
  document.getElementsByTagName('head')[0].appendChild(link) // 相当于通过link标签引入新的css样式
}
```
所谓动态添加css, 以DOM的层面来讲, 即创建一个link节点, 设置其rel和type属性, href指向静态资源服务器提供的存放css样式文件的地址, 
然后将这个link节点添加到head节点下(这里是通过appendChild(link)添加到末尾).<br>
<img src="https://github.com/ChenMingK/ImagesStore/blob/master/imgs/epubProj17.png"><br>
但是要注意如果用户一直点切换主题, 而之前添加的link节点又没有被删除的话, 虽然通过!importang能实现后面的样式覆盖之前的, 但是会降低渲染效率, 所以
为了防止重复添加样式文件, 每次执行添加操作之前需要删除之前的样式文件.具体如下:<br>

``` javaScript
// 上面用的是添加样式，重复添加只是覆盖之前的效果，加载了多个CSS，需要删除之前的
export function removeCss(href) {
  const links = document.getElementsByTagName('link')
  for (let i = links.length; i >= 0; i--) { // 从后往前遍历
    const link = links[i]
    if (link && link.getAttribute('href') && link.getAttribute('href') === href) {
      link.parentNode.removeChild(link) // 调用head标签的removeChild, 要删除的那个节点, 而不是传入节点下标什么的
    }
  }
}
// 这里设置一个删除全部的css样式的方法, 通过匹配href属性来删除, 注意不能删除其他的样式
export function removeAllCss() {
  removeCss(`${process.env.VUE_APP_RES_URL}/theme/theme_default.css`)
  removeCss(`${process.env.VUE_APP_RES_URL}/theme/theme_eye.css`)
  removeCss(`${process.env.VUE_APP_RES_URL}/theme/theme_gold.css`)
  removeCss(`${process.env.VUE_APP_RES_URL}/theme/theme_night.css`)
}
```
removeAllCss()方法即快速删除所有之前添加的样式, 因为静态资源服务器存放样式文件的位置是固定的: ip + 端口 + 文件路径, 再把将LINK节点从DOM中删除
的过程封装为一个removeCss(href)方法, 遍历所有link节点删除href属性与参数相同的. 注意删除节点的操作要通过parentNode获取父节点再调用removeChild()
方法.<br>

更多关于DOM的操作我整理在这篇文章中，CTRL点击<a href="https://blog.csdn.net/qq_37205708/article/details/89414941">传送门</a>
### 4.书签手势操作
<img src="https://github.com/ChenMingK/ImagesStore/blob/master/imgs/bookmarkgif.gif" width=300px><br>
**需求分析：**<br>
1.将标题和菜单栏隐藏后才能进行手势操作
2.未添加书签的页面下拉后添加书签
3.添加过书签的页面下拉后删除书签
4.可以通过书签直接跳转到对应的页面

**实现思路：**<br>
书签的添加由EbookReader和EbookBookmark两个组件配合完成，EbookReader组件通过touchmove和touchend事件监听手指的滑动，计算出一个Y轴偏移量offsetY
并传入vuex，EbookBookmark组件将offsetY设置为监听属性进而响应变化。注意这里在EbookBookmark中又将书签抽离为一个Bookmark组件，因为添加书签之后书签会固定在右上角但是文字和箭头却是不会显示的。

**具体过程:**<br>
这里将书签的添加过程分为以下几个阶段：<br>
第一阶段：自然下拉阶段，书签组件跟随屏幕移动而移动<br>
第二阶段：吸顶阶段，拖动值到达书签组件高度35px时书签不随屏幕移动，吸顶效果可以通过相对位移实现<br>
第三阶段：可添加状态，拖动高度超过临界值，箭头向上，文字改变，书签变色，松手后书签添加成功，覆盖在右上方<br>
书签组件高度设定为35px，临界值设定为55px，将监听到的offsetY与这两个值比较进而判定现在属于哪个阶段而做出响应。

思考1：如何计算出下拉距离？<br>
首先要知道三个移动端事件：<br>
1)touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。<br>
2)touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。<br>
3)touchend事件：当手指从屏幕上离开的时候触发。<br>



### 5.阅读进度功能实现
### 6.多级目录展示
### 7.加载动画的实现
### 8.vue-transition过渡动画的使用
### 9.公共组件Scroll.vue的开发
