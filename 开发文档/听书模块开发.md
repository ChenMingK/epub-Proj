## 使用科大讯飞在线语音合成 API
这里记录如何使用 node.js 对接科大讯飞在线语音合成 API，科大讯飞的其他产品的使用方式也类似

在线语音合成如何用在阅读器上？阅读器中的一部分章节内容（就是一串文本）提取出来转交给 node 服务器端，服务器通过科大讯飞语音合成 API 将文本转换成 MP3 格式并保存到静态资源服务器，传给前端一个下载路径，前端可以通过 audio 控件直接加载 MP3 音频文件。

这里有一个问题，在线语音合成不能一次性上传较多的文字，如何一次性将整本书的内容语音合成呢？

这里已经写好了一个 <a href="https://github.com/ChenMingK/demos/blob/master/%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90.js">demo</a>

启动 node 服务并做一些简单的修改就可以发送文字可科大讯飞平台转换成 MP3 文件并保存到本地指定路径下

## 具体步骤(建议配合给出的 demo 使用)
1.在科大讯飞平台注册登录 https://doc.xfyun.cn

<img src="https://github.com/ChenMingK/ImagesStore/blob/master/imgs/epubProj26.png" width=400px>

2.点击右上角创建新应用

<img src="https://github.com/ChenMingK/ImagesStore/blob/master/imgs/epubProj27.png" width=400px>

3.添加服务---在线语音合成，将会有一个 Web 应用可以提供的服务列表，选择在线语音合成

4.观察下图

<img src="https://github.com/ChenMingK/ImagesStore/blob/master/imgs/epubProj28.png" width=400px>

- IP 白名单：必须将 IP 添加到 IP 白名单才允许调用 API
- APIKey：调用 API 过程中必须包含的 Key
- 可用发音人：讲话的人……

5.点击开发文档可以看到详细的接口描述

<img src="https://github.com/ChenMingK/ImagesStore/blob/master/imgs/epubProj29.png" width=400px>

6.接口描述

1)授权认证，调用接口需要将 Appid，CurTime, Param 和 CheckSum 信息放在 HTTP 请求头中；

2)接口统一为 UTF-8 编码；

3)接口支持 http 和 https；

4)请求方式为 POST。

5)需配置IP白名单，详细请参照白名单。

7.授权认证相关要求

<img src="https://github.com/ChenMingK/ImagesStore/blob/master/imgs/epubProj30.png" width=500px>

**参数说明:**

appid 看自己的，X-CurTime 注意是 UTC 时间戳，X-Param 是以下内容经过 Base64 加密后的字符串

``` javaScript
const voiceParam = {
    auf: 'audio/L16;rate=16000',  // 音频采样率
    aue: 'lame',                  // 音频编码 lame:mp3格式
    voice_name: 'xiaoyan',        // 发音人
    speed,                        // 语速
    volume: '50',                 // 音量
    pitch: '50',                  // 音高
    engine_type: engineType,      // 引擎类型
    text_type: 'text'             // 文本类型
}
```
X-CheckSum 令牌，计算方法：MD5(apiKey + curTime + param)，三个值拼接的字符串，进行 MD5 哈希计算（32位小写），其中 apiKey 由讯飞提供，调用方管理。

简而言之，就是实现这几个参数放在请求头中。

整体代码如下，总体来说就是添加需要的 HTTP 请求头部信息

``` javaScript
// 处理在线语音合成API
const express = require('express')         // express库
const Base64 = require('js-base64').Base64 // Base64库用来加密 cnpm i -S js-base64
const md5 = require('js-md5')              // 也是加密库 cnpm i -S js-md5
const qs = require('qs')                   // 对字符串进行处理，让其变为POST请求中可以识别的键值对形式 cnpm i -S qs
const http = require('http')               // http库 cnpm i -S http 发送HTTP请求
const resUrl = require('./const').resUrl
const fs = require('fs')                   // fs库，文件操作,内置库

const app = express()
// 监听的端口号，回调函数
const server = app.listen(3000, () => {
  const host = server.address().address
  const port = server.address().port
  console.log('server is listening at http://%s:%s', host, port)
})
const mp3FilePath = 'D:/software/servicetools/nginx-1.14.2/resource/mp3' // 这个是本地路径,本地存储文件
// voice
app.get('/voice', (req, res) => {
  createVoice(req, res)
})
function createVoice(req, res) {
  // const text = req.query.text // 文本
  const lang = 'cn' // 语言 --- 科大讯飞中文朗读比较好英文不太好
  const text = '测试科大讯飞在线语音合成api的功能,比如说，我们输入一段话,科大讯飞api会在线生成语音返回给客户端' // 不超过1000字
  let engineType = 'intp65' // s引擎类型
  /* if (lang.toLowerCase() === 'en') {
    engineType = 'intp65_en'
  } */
  let speed = '30' // 朗读速度，可调节
  // 参数具体参考开发文档
  const voiceParam = {
    auf: 'audio/L16;rate=16000',  // 音频采样率
    aue: 'lame',                  // 音频编码 lame:mp3格式
    voice_name: 'xiaoyan',        // 发音人
    speed,                        // 语速
    volume: '50',                 // 音量
    pitch: '50',                  // 音高
    engine_type: engineType,      // 引擎类型
    text_type: 'text'             // 文本类型
  }
  // 认证部分
  console.log(new Date().getTime() / 1000)
  const currentTime = Math.floor(new Date().getTime() / 1000) // /1000转化为UTC时间戳, floor转化为整型
  const appId = '5ca896ce'
  const apiKey = 'dd3f9e9e19ac54c31b82b58fd3a23ecc' // 看自己的API Key
  // X-Param头Base64加密 使用Base64的encode方法
  const xParam = Base64.encode(JSON.stringify(voiceParam))
  // X-CheckSum令牌，计算方法：MD5(apiKey + curTime + param)，
  // 三个值拼接的字符串，进行MD5哈希计算（32位小写）
  const checkSum = md5(apiKey + currentTime + xParam)
  const headers = {}
  // 接口统一为 UTF-8 编码,请求方式为POST
  headers['Content-Type'] = 'application/x-www-form-urlencoded;charset=utf-8'
  headers['X-Param'] = xParam
  headers['X-Appid'] = appId
  headers['X-CurTime'] = currentTime
  headers['X-CheckSum'] = checkSum
  headers['X-Real-Ip'] = '127.0.0.1'  // IP地址

  // qs库处理文本
  const data = qs.stringify({
    text: text
  })

  // POST http[s]://api.xfyun.cn/v1/service/v1/tts HTTP/1.1
  // Content-Type:application/x-www-form-urlencoded; charset=utf-8
  // 请求的参数
  const options = {
    host: 'api.xfyun.cn',
    path: '/v1/service/v1/tts',
    method: 'POST',
    headers
  }
  // 发送HTTP请求
  const request = http.request(options, response => {
    // console.log(response)
    let mp3 = ''
    const contentLength = response.headers['content-length']
    response.setEncoding('binary') // 将编码格式定为二进制文件
    response.on('data', data => {
      // console.log(data) // Buffer
      mp3 += data
      const process = data.length / contentLength * 100
      const percent = parseInt(process.toFixed(2))
      console.log(percent)
    })
    // end回调
    response.on('end', () => {
      // console.log(mp3) // 如果返回的数据有illegal client_ip的话把这个ip添加到IP白名单中
      // 有可能返回一个text-html而不是audio，404?

      const fileName = new Date().getTime() // 以时间戳作为文件名保证不重复
      const filePath = `${mp3FilePath}/${fileName}.mp3` // 路径+文件名 注意路径是本地路径,最后是文件格式
      const downloadUrl = `${resUrl}/mp3/${fileName}.mp3` // 下载路径，返回给前端，前端可通过该路径下载
      // 路径，数据，文件类型
      fs.writeFile(filePath, mp3, 'binary', err => {
        if (err) {
          res.json({
            error: 1,
            msg: '下载失败'
          })
        } else {
          res.json({
            error: 0,
            msg: '下载成功',
            path: downloadUrl
          })
        }
      })
      // console.log(filePath, downloadUrl)
    })
  })
  request.write(data)
  request.end()
}
```

## \<audio> 组件的使用
``` html
<audio src="./music.mp3"
       @canplay="onCanPlay"
       @timeupdate="onTimeUpdate"
       @ended="onAudioEnded"
       ref="audio"></audio> <!--不加 controls 就不会显示-->
```
使用 H5 的 \<audio> 标签可以很方便地加载音频，但是不同浏览器的实现样式各不相同且都有一个共同点---丑。所以我们要去掉默认样式写上自己的样式。

没有了默认样式怎样控制音频文件呢？这就需要了解该标签默认的一些属性和事件了

详细的可以参考 <a href="https://www.jianshu.com/p/1fe701c9179f">这篇文章</a>

上面的代码中为 `canplay`、`timeupdate`、`ended` 事件设置了事件处理程序，这几个事件都是比较重要的

- canplay：src 加载完毕后触发该事件，表示可以播放音频了
- timeupdate：播放的过程中会持续触发的事件
- ended：播放完成时触发的事件

另外 audio 控件有几个重要的属性也得记住
- currentTime：当前播放时间，以秒为单位
- duration：总时长，以秒为单位

可以这么获取
- `this.currentPlayingTime = this.$refs.audio.currentTime`  
- `this.totalPlayingTime = this.$refs.audio.duration`


